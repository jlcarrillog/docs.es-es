---
title: Reglas de confiabilidad (análisis de código)
description: Más información sobre las reglas de confiabilidad del análisis de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/07/2020
ms.locfileid: "96594426"
---
# <a name="reliability-rules"></a><span data-ttu-id="2cee1-103">Reglas de confiabilidad</span><span class="sxs-lookup"><span data-stu-id="2cee1-103">Reliability rules</span></span>

<span data-ttu-id="2cee1-104">Las reglas de confiabilidad admiten la confiabilidad de bibliotecas y aplicaciones, como la correcta utilización de la memoria y el subproceso.</span><span class="sxs-lookup"><span data-stu-id="2cee1-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="2cee1-105">Las reglas de confiabilidad incluyen:</span><span class="sxs-lookup"><span data-stu-id="2cee1-105">The reliability rules include:</span></span>

|<span data-ttu-id="2cee1-106">Regla</span><span class="sxs-lookup"><span data-stu-id="2cee1-106">Rule</span></span>|<span data-ttu-id="2cee1-107">Descripción</span><span class="sxs-lookup"><span data-stu-id="2cee1-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="2cee1-108">CA2000: Desechar objetos antes de perder el ámbito</span><span class="sxs-lookup"><span data-stu-id="2cee1-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="2cee1-109">Dado que podría producirse un evento excepcional que evitaría que el finalizador de un objeto se ejecutase, el objeto debe estar disponible en su lugar antes de que todas las referencias a él estén fuera del ámbito.</span><span class="sxs-lookup"><span data-stu-id="2cee1-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="2cee1-110">CA2002: No bloquear objetos con identidad débil</span><span class="sxs-lookup"><span data-stu-id="2cee1-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="2cee1-111">Se dice que un objeto tiene una identidad débil cuando se puede tener acceso directamente a través de los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="2cee1-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="2cee1-112">Un subproceso que intenta obtener un bloqueo en un objeto que tiene identidad débil se puede bloquear con un segundo subproceso en un dominio de aplicación diferente que tenga bloqueado el mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="2cee1-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="2cee1-113">CA2007: No esperar una tarea directamente</span><span class="sxs-lookup"><span data-stu-id="2cee1-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="2cee1-114">Un método asincrónico [espera](../../../csharp/language-reference/operators/await.md) <xref:System.Threading.Tasks.Task> directamente.</span><span class="sxs-lookup"><span data-stu-id="2cee1-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="2cee1-115">CA2008: No crear tareas sin pasar un elemento TaskScheduler</span><span class="sxs-lookup"><span data-stu-id="2cee1-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="2cee1-116">Una operación de creación o continuación de tareas utiliza una sobrecarga de método que no especifica un <xref:System.Threading.Tasks.TaskScheduler> parámetro.</span><span class="sxs-lookup"><span data-stu-id="2cee1-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="2cee1-117">CA2009: No llame a ToImmutableCollection en un valor ImmutableCollection</span><span class="sxs-lookup"><span data-stu-id="2cee1-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="2cee1-118">`ToImmutable` se llamó innecesariamente al método en una colección inmutable desde el <xref:System.Collections.Immutable> espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="2cee1-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="2cee1-119">CA2011: No asignar la propiedad dentro de su establecedor</span><span class="sxs-lookup"><span data-stu-id="2cee1-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="2cee1-120">Se asignó accidentalmente un valor a una propiedad dentro de su propio [descriptor de acceso set](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span><span class="sxs-lookup"><span data-stu-id="2cee1-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="2cee1-121">CA2012: Usar ValueTasks correctamente</span><span class="sxs-lookup"><span data-stu-id="2cee1-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="2cee1-122">Los ValueTasks devueltos de las invocaciones de miembro están diseñados para esperarse directamente.</span><span class="sxs-lookup"><span data-stu-id="2cee1-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="2cee1-123">Los intentos de consumir un ValueTask varias veces o de tener acceso directamente a uno de los resultados antes de que se sepa que se han completado pueden producir una excepción o daños.</span><span class="sxs-lookup"><span data-stu-id="2cee1-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="2cee1-124">Omitir tal ValueTask es probable que se trate de un error funcional y puede degradar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="2cee1-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="2cee1-125">CA2013: No usar ReferenceEquals con tipos de valor</span><span class="sxs-lookup"><span data-stu-id="2cee1-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="2cee1-126">Al comparar valores mediante <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> , si objA y objB son tipos de valor, se les aplica la conversión boxing antes de que se pasen al <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2cee1-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="2cee1-127">Esto significa que, aunque objA y objB representen la misma instancia de un tipo de valor, el <xref:System.Object.ReferenceEquals%2A> método devuelve false.</span><span class="sxs-lookup"><span data-stu-id="2cee1-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="2cee1-128">CA2014: no use stackalloc en los bucles.</span><span class="sxs-lookup"><span data-stu-id="2cee1-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="2cee1-129">El espacio de pila asignado por stackalloc solo se libera al final de la invocación del método actual.</span><span class="sxs-lookup"><span data-stu-id="2cee1-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="2cee1-130">Su uso en un bucle puede dar lugar a un crecimiento de pila sin enlazar y a condiciones de desbordamiento de pila eventuales.</span><span class="sxs-lookup"><span data-stu-id="2cee1-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="2cee1-131">CA2015: no definir finalizadores para los tipos derivados de MemoryManager &lt; T&gt;</span><span class="sxs-lookup"><span data-stu-id="2cee1-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="2cee1-132">Agregar un finalizador a un tipo derivado de <xref:System.Buffers.MemoryManager%601> puede permitir que la memoria se libere mientras esté siendo utilizada por <xref:System.Span%601> .</span><span class="sxs-lookup"><span data-stu-id="2cee1-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="2cee1-133">CA2016: Reenviar el parámetro CancellationToken a los métodos que lo usan</span><span class="sxs-lookup"><span data-stu-id="2cee1-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="2cee1-134">Reenvíe el `CancellationToken` parámetro a los métodos que toman uno para asegurarse de que las notificaciones de cancelación de la operación se propagan correctamente, o que `CancellationToken.None` se pasan explícitamente para indicar que no se propague el token de forma intencionada.</span><span class="sxs-lookup"><span data-stu-id="2cee1-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
