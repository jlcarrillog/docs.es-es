---
title: Reglas de rendimiento (análisis de código)
description: Obtenga información sobre las reglas de rendimiento del análisis de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/25/2020
ms.locfileid: "96592402"
---
# <a name="performance-rules"></a><span data-ttu-id="8e96e-103">Reglas de rendimiento</span><span class="sxs-lookup"><span data-stu-id="8e96e-103">Performance rules</span></span>

<span data-ttu-id="8e96e-104">Las reglas de rendimiento admiten aplicaciones y bibliotecas de alto rendimiento.</span><span class="sxs-lookup"><span data-stu-id="8e96e-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="8e96e-105">En esta sección</span><span class="sxs-lookup"><span data-stu-id="8e96e-105">In this section</span></span>

| <span data-ttu-id="8e96e-106">Regla</span><span class="sxs-lookup"><span data-stu-id="8e96e-106">Rule</span></span> | <span data-ttu-id="8e96e-107">Descripción</span><span class="sxs-lookup"><span data-stu-id="8e96e-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="8e96e-108">CA1802: Utilizar literales cuando sea apropiado</span><span class="sxs-lookup"><span data-stu-id="8e96e-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="8e96e-109">Un campo se declara estático y de solo lectura (Shared y ReadOnly en Visual Basic) y se inicializa con un valor que se calcula en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="8e96e-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="8e96e-110">Dado que el valor asignado al campo de destino es calculable en tiempo de compilación, cambie la declaración a un campo const (const en Visual Basic) para que el valor se calcule en tiempo de compilación en lugar de en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="8e96e-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="8e96e-111">CA1805: no inicializar innecesariamente</span><span class="sxs-lookup"><span data-stu-id="8e96e-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="8e96e-112">El tiempo de ejecución de .NET inicializa todos los campos de los tipos de referencia a sus valores predeterminados antes de ejecutar el constructor.</span><span class="sxs-lookup"><span data-stu-id="8e96e-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="8e96e-113">En la mayoría de los casos, la inicialización explícita de un campo a su valor predeterminado es redundante, lo que aumenta los costos de mantenimiento y puede degradar el rendimiento (por ejemplo, con un mayor tamaño de ensamblado).</span><span class="sxs-lookup"><span data-stu-id="8e96e-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="8e96e-114">CA1806: No omitir resultados del método</span><span class="sxs-lookup"><span data-stu-id="8e96e-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="8e96e-115">Se crea un nuevo objeto, pero nunca se utiliza, o se llama a un método que crea y devuelve una nueva cadena y la nueva cadena nunca se utiliza, o un modelo de objetos componentes (COM) o un método P/Invoke devuelve un código de error o HRESULT que nunca se usa.</span><span class="sxs-lookup"><span data-stu-id="8e96e-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="8e96e-116">CA1810: Inicializar campos estáticos de tipo de referencia insertados</span><span class="sxs-lookup"><span data-stu-id="8e96e-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="8e96e-117">Cuando un tipo declara un constructor estático explícito, el compilador Just-In-Time (JIT) agrega una comprobación a cada constructor de instancia y a cada método estático del tipo para asegurarse de que se ha llamado anteriormente al constructor estático.</span><span class="sxs-lookup"><span data-stu-id="8e96e-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="8e96e-118">Las comprobaciones del constructor estático pueden reducir el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="8e96e-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="8e96e-119">CA1812: Evitar las clases internas sin instancia</span><span class="sxs-lookup"><span data-stu-id="8e96e-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="8e96e-120">El código del ensamblado no crea una instancia del tipo del nivel de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="8e96e-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="8e96e-121">CA1813: Evitar los atributos no sellados</span><span class="sxs-lookup"><span data-stu-id="8e96e-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="8e96e-122">.NET proporciona métodos para recuperar atributos personalizados.</span><span class="sxs-lookup"><span data-stu-id="8e96e-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="8e96e-123">De forma predeterminada, estos métodos buscan la jerarquía de herencia de atributo.</span><span class="sxs-lookup"><span data-stu-id="8e96e-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="8e96e-124">La acción de sellar el atributo elimina la búsqueda en la jerarquía de herencia y puede mejorarse el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="8e96e-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="8e96e-125">CA1814: Preferir matrices escalonadas antes que multidimensionales</span><span class="sxs-lookup"><span data-stu-id="8e96e-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="8e96e-126">Una matriz escalonada es una matriz cuyos elementos son matrices.</span><span class="sxs-lookup"><span data-stu-id="8e96e-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="8e96e-127">Las matrices que componen los elementos pueden tener distintos tamaños, lo que puede dar lugar a menos espacio desperdiciado para algunos conjuntos de datos.</span><span class="sxs-lookup"><span data-stu-id="8e96e-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="8e96e-128">CA1815: Invalidar Equals y el operador Equals en los tipos de valores</span><span class="sxs-lookup"><span data-stu-id="8e96e-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="8e96e-129">Para los tipos de valor, la implementación heredada de Equals utiliza la biblioteca de reflexión y compara el contenido de todos los campos.</span><span class="sxs-lookup"><span data-stu-id="8e96e-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="8e96e-130">Mediante el cálculo, la reflexión es cara y no es necesario comparar cada campo para comprobar si hay igualdad.</span><span class="sxs-lookup"><span data-stu-id="8e96e-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="8e96e-131">Si espera que los usuarios comparen u ordenen instancias, o utilicen instancias como claves de tabla hash, el tipo de valor debe implementar Equals.</span><span class="sxs-lookup"><span data-stu-id="8e96e-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="8e96e-132">CA1819: Las propiedades no deben devolver matrices</span><span class="sxs-lookup"><span data-stu-id="8e96e-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="8e96e-133">Las matrices devueltas por propiedades no están protegidas contra escritura, aunque la propiedad sea de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="8e96e-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="8e96e-134">Para mantener la matriz inviolable, la propiedad debe devolver una copia de la matriz.</span><span class="sxs-lookup"><span data-stu-id="8e96e-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="8e96e-135">Por lo general, los usuarios no entienden las implicaciones de rendimiento adversas que se originan al llamar a este tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="8e96e-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="8e96e-136">CA1820: Comprobar si las cadenas están vacías mediante la longitud de cadena</span><span class="sxs-lookup"><span data-stu-id="8e96e-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="8e96e-137">El uso de la propiedad String.Length o del método String.IsNullOrEmpty para comparar cadenas es mucho más rápido que el uso de Equals.</span><span class="sxs-lookup"><span data-stu-id="8e96e-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="8e96e-138">CA1821: Quitar finalizadores vacíos</span><span class="sxs-lookup"><span data-stu-id="8e96e-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="8e96e-139">Siempre que pueda, evite los finalizadores debido a la sobrecarga de rendimiento adicional necesaria para el seguimiento de la duración del objeto.</span><span class="sxs-lookup"><span data-stu-id="8e96e-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="8e96e-140">Un finalizador vacío supone una sobrecarga adicional sin ninguna ventaja.</span><span class="sxs-lookup"><span data-stu-id="8e96e-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="8e96e-141">CA1822: Marcar miembros como estáticos</span><span class="sxs-lookup"><span data-stu-id="8e96e-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="8e96e-142">Los miembros que no tienen acceso a los datos de instancia o a los métodos de instancia de llamada se pueden marcar como estáticos (compartidos en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8e96e-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="8e96e-143">Después de marcar los métodos como static, el compilador emite los sitios de llamada no virtuales para estos miembros.</span><span class="sxs-lookup"><span data-stu-id="8e96e-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="8e96e-144">Esto puede proporcionar una mejora apreciable del rendimiento del código en el que el rendimiento es fundamental.</span><span class="sxs-lookup"><span data-stu-id="8e96e-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="8e96e-145">CA1823: Evitar los campos privados sin utilizar</span><span class="sxs-lookup"><span data-stu-id="8e96e-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="8e96e-146">Se detectaron campos privados a los que no parece que se tenga acceso en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="8e96e-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="8e96e-147">CA1824: Marcar los ensamblados con NeutralResourcesLanguageAttribute</span><span class="sxs-lookup"><span data-stu-id="8e96e-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="8e96e-148">El atributo NeutralResourcesLanguage informa al Administrador de recursos del lenguaje que se usó para mostrar los recursos de una referencia cultural neutra para un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="8e96e-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="8e96e-149">Esto mejora el rendimiento de la búsqueda del primer recurso que se carga y puede reducir el espacio de trabajo.</span><span class="sxs-lookup"><span data-stu-id="8e96e-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="8e96e-150">CA1825: Evitar asignaciones de matrices de longitud cero</span><span class="sxs-lookup"><span data-stu-id="8e96e-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="8e96e-151">Al inicializar una matriz de longitud cero, se produce una asignación de memoria innecesaria.</span><span class="sxs-lookup"><span data-stu-id="8e96e-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="8e96e-152">En su lugar, use la instancia de matriz vacía asignada estáticamente mediante una llamada a <xref:System.Array.Empty%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="8e96e-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8e96e-153">La asignación de memoria se comparte entre todas las invocaciones de este método.</span><span class="sxs-lookup"><span data-stu-id="8e96e-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="8e96e-154">CA1826: Usar la propiedad en lugar del método Linq Enumerable</span><span class="sxs-lookup"><span data-stu-id="8e96e-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="8e96e-155"><xref:System.Linq.Enumerable> El método LINQ se usó en un tipo que admite una propiedad equivalente y más eficaz.</span><span class="sxs-lookup"><span data-stu-id="8e96e-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="8e96e-156">CA1827: No usar Count/LongCount si se puede usar Any</span><span class="sxs-lookup"><span data-stu-id="8e96e-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="8e96e-157"><xref:System.Linq.Enumerable.Count%2A><xref:System.Linq.Enumerable.LongCount%2A>se usó el método o, donde el <xref:System.Linq.Enumerable.Any%2A> método sería más eficaz.</span><span class="sxs-lookup"><span data-stu-id="8e96e-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="8e96e-158">CA1828: No usar CountAsync/LongCountAsync si se puede usar AnyAsync</span><span class="sxs-lookup"><span data-stu-id="8e96e-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="8e96e-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A>se usó el método o, donde el <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> método sería más eficaz.</span><span class="sxs-lookup"><span data-stu-id="8e96e-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="8e96e-160">CA1829: Usar la propiedad Length/Count en lugar del método Enumerable.Count</span><span class="sxs-lookup"><span data-stu-id="8e96e-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="8e96e-161"><xref:System.Linq.Enumerable.Count%2A> El método LINQ se usó en un tipo que admite una propiedad equivalente, más eficaz `Length` o `Count` .</span><span class="sxs-lookup"><span data-stu-id="8e96e-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="8e96e-162">CA1830: Preferir las sobrecargas de método Append e Insert fuertemente tipadas en StringBuilder</span><span class="sxs-lookup"><span data-stu-id="8e96e-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="8e96e-163"><xref:System.Text.StringBuilder.Append%2A> y <xref:System.Text.StringBuilder.Insert%2A> proporcionan sobrecargas para varios tipos más allá de System. String.</span><span class="sxs-lookup"><span data-stu-id="8e96e-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="8e96e-164">Siempre que sea posible, prefiera las sobrecargas fuertemente tipadas sobre el uso de ToString () y la sobrecarga basada en cadena.</span><span class="sxs-lookup"><span data-stu-id="8e96e-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="8e96e-165">CA1831: Usar AsSpan en lugar de indizadores basados en intervalos para una cadena cuando proceda</span><span class="sxs-lookup"><span data-stu-id="8e96e-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="8e96e-166">Cuando se usa un indexador de intervalo en una cadena y se asigna implícitamente el valor a un &lt; tipo char ReadOnlySpan &gt; , se utilizará el método en <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> lugar de <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , que genera una copia de la parte solicitada de la cadena.</span><span class="sxs-lookup"><span data-stu-id="8e96e-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="8e96e-167">CA1832: Usar AsSpan o AsMemory en lugar de indizadores basados en intervalos para obtener la parte ReadOnlySpan o ReadOnlyMemory de una matriz</span><span class="sxs-lookup"><span data-stu-id="8e96e-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="8e96e-168">Cuando se usa un indexador de intervalo en una matriz y se asigna implícitamente el valor a un <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> tipo o, se utilizará el método en <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> lugar de <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , que genera una copia de la parte solicitada de la matriz.</span><span class="sxs-lookup"><span data-stu-id="8e96e-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="8e96e-169">CA1833: Usar AsSpan o AsMemory en lugar de indizadores basados en intervalos para obtener la parte Span o Memory de una matriz</span><span class="sxs-lookup"><span data-stu-id="8e96e-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="8e96e-170">Cuando se usa un indexador de intervalo en una matriz y se asigna implícitamente el valor a un <xref:System.Span%601> <xref:System.Memory%601> tipo o, se utilizará el método en <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> lugar de <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , que genera una copia de la parte solicitada de la matriz.</span><span class="sxs-lookup"><span data-stu-id="8e96e-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="8e96e-171">CA1834: Usar StringBuilder.Append(char) para cadenas de un solo carácter</span><span class="sxs-lookup"><span data-stu-id="8e96e-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="8e96e-172"><xref:System.Text.StringBuilder> tiene una `Append` sobrecarga que toma `char` como argumento.</span><span class="sxs-lookup"><span data-stu-id="8e96e-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="8e96e-173">Prefiera llamar `char` a la sobrecarga para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="8e96e-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="8e96e-174">CA1835: preferir las sobrecargas basadas en Memory' para ' ReadAsync ' y ' WriteAsync '</span><span class="sxs-lookup"><span data-stu-id="8e96e-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="8e96e-175">' Stream ' tiene una sobrecarga ' ReadAsync ' que toma un ' byte de memoria &lt; &gt; ' como primer argumento y una sobrecarga ' WriteAsync ' que toma un ' ReadOnlyMemory &lt; byte &gt; ' como primer argumento.</span><span class="sxs-lookup"><span data-stu-id="8e96e-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="8e96e-176">Prefiera llamar a las sobrecargas basadas en memoria, que son más eficaces.</span><span class="sxs-lookup"><span data-stu-id="8e96e-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="8e96e-177">CA1836: preferir `IsEmpty` `Count` cuando esté disponible</span><span class="sxs-lookup"><span data-stu-id="8e96e-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="8e96e-178">Propiedad preferida `IsEmpty` que es más eficaz `Count` que `Length` , <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> o <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar si el objeto contiene o no elementos.</span><span class="sxs-lookup"><span data-stu-id="8e96e-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="8e96e-179">CA1837: use `Environment.ProcessId` en lugar de `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="8e96e-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="8e96e-180">`Environment.ProcessId` es más sencillo y más rápido que `Process.GetCurrentProcess().Id` .</span><span class="sxs-lookup"><span data-stu-id="8e96e-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="8e96e-181">CA1838: evitar `StringBuilder` parámetros para P/Invoke</span><span class="sxs-lookup"><span data-stu-id="8e96e-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="8e96e-182">La serialización de `StringBuilder` siempre crea una copia de búfer nativa, lo que da lugar a varias asignaciones para una operación de serialización.</span><span class="sxs-lookup"><span data-stu-id="8e96e-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
