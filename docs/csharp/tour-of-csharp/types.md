---
title: 'Definición de tipos y sus miembros: un recorrido por C#'
description: Los bloques de creación de los programas son los tipos. Aprenda a crear clases, estructuras, interfaces y mucho más en C#.
ms.date: 08/06/2020
ms.openlocfilehash: efd353fe8c1e6a57952bcb2586a05ad38ecd52b9
ms.sourcegitcommit: 0802ac583585110022beb6af8ea0b39188b77c43
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "88559120"
---
# <a name="types-and-members"></a><span data-ttu-id="d74a6-104">Tipos y miembros</span><span class="sxs-lookup"><span data-stu-id="d74a6-104">Types and members</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="d74a6-105">Clases y objetos</span><span class="sxs-lookup"><span data-stu-id="d74a6-105">Classes and objects</span></span>

<span data-ttu-id="d74a6-106">Las *clases* son los tipos más fundamentales de C#.</span><span class="sxs-lookup"><span data-stu-id="d74a6-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="d74a6-107">Una clase es una estructura de datos que combina estados (campos) y acciones (métodos y otros miembros de función) en una sola unidad.</span><span class="sxs-lookup"><span data-stu-id="d74a6-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="d74a6-108">Una clase proporciona una definición para *instancias* de la clase, también conocidas como *objetos*.</span><span class="sxs-lookup"><span data-stu-id="d74a6-108">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="d74a6-109">Las clases admiten *herencia* y *polimorfismo*, mecanismos por los que las *clases derivadas* pueden extender y especializar *clases base*.</span><span class="sxs-lookup"><span data-stu-id="d74a6-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="d74a6-110">Las clases nuevas se crean mediante declaraciones de clase.</span><span class="sxs-lookup"><span data-stu-id="d74a6-110">New classes are created using class declarations.</span></span> <span data-ttu-id="d74a6-111">Una declaración de clase comienza con un encabezado.</span><span class="sxs-lookup"><span data-stu-id="d74a6-111">A class declaration starts with a header.</span></span> <span data-ttu-id="d74a6-112">El encabezado especifica lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="d74a6-112">The header specifies:</span></span>

- <span data-ttu-id="d74a6-113">Atributos y modificadores de la clase</span><span class="sxs-lookup"><span data-stu-id="d74a6-113">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="d74a6-114">Nombre de la clase</span><span class="sxs-lookup"><span data-stu-id="d74a6-114">The name of the class</span></span>
- <span data-ttu-id="d74a6-115">Clase base (al heredar de una [clase base](#base-classes))</span><span class="sxs-lookup"><span data-stu-id="d74a6-115">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="d74a6-116">Interfaces implementadas por la clase</span><span class="sxs-lookup"><span data-stu-id="d74a6-116">The interfaces implemented by the class.</span></span>

<span data-ttu-id="d74a6-117">Al encabezado le sigue el cuerpo de la clase, que consta de una lista de declaraciones de miembros escritas entre los delimitadores `{` y `}`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-117">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="d74a6-118">En el código siguiente se muestra una declaración de una clase simple denominada `Point`:</span><span class="sxs-lookup"><span data-stu-id="d74a6-118">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="d74a6-119">Las instancias de clases se crean mediante el operador `new`, que asigna memoria para una nueva instancia, invoca un constructor para inicializar la instancia y devuelve una referencia a la instancia.</span><span class="sxs-lookup"><span data-stu-id="d74a6-119">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="d74a6-120">Las instrucciones siguientes crean dos objetos `Point` y almacenan las referencias en esos objetos en dos variables:</span><span class="sxs-lookup"><span data-stu-id="d74a6-120">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="d74a6-121">La memoria ocupada por un objeto se reclama automáticamente cuando el objeto ya no es accesible.</span><span class="sxs-lookup"><span data-stu-id="d74a6-121">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="d74a6-122">En C#, no es necesario ni posible desasignar objetos de forma explícita.</span><span class="sxs-lookup"><span data-stu-id="d74a6-122">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="d74a6-123">Parámetros de tipo</span><span class="sxs-lookup"><span data-stu-id="d74a6-123">Type parameters</span></span>

<span data-ttu-id="d74a6-124">Las clases genéricas definen [\***parámetros de tipo** _](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="d74a6-124">Generic classes define [\***type parameters** _](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="d74a6-125">Los parámetros de tipo son una lista de nombres de parámetros de tipo entre paréntesis angulares.</span><span class="sxs-lookup"><span data-stu-id="d74a6-125">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="d74a6-126">Los parámetros de tipo siguen el nombre de la clase.</span><span class="sxs-lookup"><span data-stu-id="d74a6-126">Type parameters follow the class name.</span></span> <span data-ttu-id="d74a6-127">Los parámetros de tipo pueden usarse luego en el cuerpo de las declaraciones de clase para definir a los miembros de la clase.</span><span class="sxs-lookup"><span data-stu-id="d74a6-127">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="d74a6-128">En el ejemplo siguiente, los parámetros de tipo de `Pair` son `TFirst` y `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="d74a6-128">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="d74a6-129">Un tipo de clase que se declara para tomar parámetros de tipo se denomina _tipo de clase genérica\*.</span><span class="sxs-lookup"><span data-stu-id="d74a6-129">A class type that is declared to take type parameters is called a _generic class type\*.</span></span> <span data-ttu-id="d74a6-130">Los tipos de estructura, interfaz y delegado también pueden ser genéricos.</span><span class="sxs-lookup"><span data-stu-id="d74a6-130">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="d74a6-131">Cuando se usa la clase genérica, se deben proporcionar argumentos de tipo para cada uno de los parámetros de tipo:</span><span class="sxs-lookup"><span data-stu-id="d74a6-131">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="d74a6-132">Un tipo genérico con argumentos de tipo proporcionado, como `Pair<int,string>` anteriormente, se conoce como *tipo construido*.</span><span class="sxs-lookup"><span data-stu-id="d74a6-132">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="d74a6-133">Clases base</span><span class="sxs-lookup"><span data-stu-id="d74a6-133">Base classes</span></span>

<span data-ttu-id="d74a6-134">Una declaración de clase puede especificar una clase base.</span><span class="sxs-lookup"><span data-stu-id="d74a6-134">A class declaration may specify a base class.</span></span> <span data-ttu-id="d74a6-135">Tras el nombre de clase y los parámetros de tipo, agregue un signo de dos puntos y el nombre de la clase base.</span><span class="sxs-lookup"><span data-stu-id="d74a6-135">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="d74a6-136">Omitir una especificación de la clase base es igual que derivarla del tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-136">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="d74a6-137">En el ejemplo siguiente, la clase base de `Point3D` es `Point`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-137">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="d74a6-138">En el primer ejemplo, la clase base de `Point` es `object`:</span><span class="sxs-lookup"><span data-stu-id="d74a6-138">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="d74a6-139">Una clase hereda a los miembros de su clase base.</span><span class="sxs-lookup"><span data-stu-id="d74a6-139">A class inherits the members of its base class.</span></span> <span data-ttu-id="d74a6-140">La herencia significa que una clase contiene implícitamente casi todos los miembros de su clase base.</span><span class="sxs-lookup"><span data-stu-id="d74a6-140">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="d74a6-141">Una clase no hereda la instancia, los constructores estáticos ni el finalizador.</span><span class="sxs-lookup"><span data-stu-id="d74a6-141">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="d74a6-142">Una clase derivada puede agregar nuevos miembros a aquellos de los que hereda, pero no puede quitar la definición de un miembro heredado.</span><span class="sxs-lookup"><span data-stu-id="d74a6-142">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="d74a6-143">En el ejemplo anterior, `Point3D` hereda los miembros `X` y `Y` de `Point`, y cada instancia de `Point3D` contiene tres miembros: `X`, `Y` y `Z`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-143">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="d74a6-144">Existe una conversión implícita de un tipo de clase a cualquiera de sus tipos de clase base.</span><span class="sxs-lookup"><span data-stu-id="d74a6-144">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="d74a6-145">Una variable de un tipo de clase puede hacer referencia a una instancia de esa clase o a una instancia de cualquier clase derivada.</span><span class="sxs-lookup"><span data-stu-id="d74a6-145">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="d74a6-146">Por ejemplo, dadas las declaraciones de clase anteriores, una variable de tipo `Point` puede hacer referencia a una instancia de `Point` o `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="d74a6-146">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="d74a6-147">Estructuras</span><span class="sxs-lookup"><span data-stu-id="d74a6-147">Structs</span></span>

<span data-ttu-id="d74a6-148">Las clases definen tipos que admiten la herencia y el polimorfismo.</span><span class="sxs-lookup"><span data-stu-id="d74a6-148">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="d74a6-149">Permiten crear comportamientos sofisticados basados en jerarquías de clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="d74a6-149">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="d74a6-150">Por el contrario, los tipos [\***struct** _](../language-reference/builtin-types/struct.md) son tipos más sencillos cuyo propósito principal es almacenar valores de datos.</span><span class="sxs-lookup"><span data-stu-id="d74a6-150">By contrast, [\***struct** _](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="d74a6-151">Dichos tipos struct no pueden declarar un tipo base; se derivan implícitamente de <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d74a6-151">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d74a6-152">No se pueden derivar otros tipos de `struct` a partir de un tipo de `struct`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-152">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="d74a6-153">Están sellados implícitamente.</span><span class="sxs-lookup"><span data-stu-id="d74a6-153">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="d74a6-154">Interfaces</span><span class="sxs-lookup"><span data-stu-id="d74a6-154">Interfaces</span></span>

<span data-ttu-id="d74a6-155">Una [_*_interfaz_*_](../programming-guide/interfaces/index.md) define un contrato que se puede implementar mediante clases y estructuras.</span><span class="sxs-lookup"><span data-stu-id="d74a6-155">An [_*_interface_*_](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="d74a6-156">Una interfaz puede contener métodos, propiedades, eventos e indexadores.</span><span class="sxs-lookup"><span data-stu-id="d74a6-156">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="d74a6-157">Normalmente, una interfaz no proporciona implementaciones de los miembros que define, sino que simplemente especifica los miembros que se deben proporcionar mediante clases o estructuras que implementan la interfaz.</span><span class="sxs-lookup"><span data-stu-id="d74a6-157">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="d74a6-158">Las interfaces pueden usar la _*_herencia múltiple_*_.</span><span class="sxs-lookup"><span data-stu-id="d74a6-158">Interfaces may employ _*_multiple inheritance_*_.</span></span> <span data-ttu-id="d74a6-159">En el ejemplo siguiente, la interfaz `IComboBox` hereda de `ITextBox` y `IListBox`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-159">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="d74a6-160">Las clases y los structs pueden implementar varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="d74a6-160">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="d74a6-161">En el ejemplo siguiente, la clase `EditBox` implementa `IControl` y `IDataBound`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-161">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="d74a6-162">Cuando una clase o un struct implementan una interfaz determinada, las instancias de esa clase o struct se pueden convertir implícitamente a ese tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="d74a6-162">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="d74a6-163">Por ejemplo</span><span class="sxs-lookup"><span data-stu-id="d74a6-163">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="d74a6-164">Enumeraciones</span><span class="sxs-lookup"><span data-stu-id="d74a6-164">Enums</span></span>

<span data-ttu-id="d74a6-165">Un tipo de [_*_enumeración_*_](../language-reference/builtin-types/enum.md) define un conjunto de valores constantes.</span><span class="sxs-lookup"><span data-stu-id="d74a6-165">An [_*_Enum_*_](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="d74a6-166">En el elemento `enum` siguiente se declaran constantes que definen diferentes verduras de raíz:</span><span class="sxs-lookup"><span data-stu-id="d74a6-166">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="d74a6-167">También puede definir un elemento `enum` que se usará de forma combinada como marcas.</span><span class="sxs-lookup"><span data-stu-id="d74a6-167">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="d74a6-168">La declaración siguiente declara un conjunto de marcas para las cuatro estaciones.</span><span class="sxs-lookup"><span data-stu-id="d74a6-168">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="d74a6-169">Se puede aplicar cualquier combinación de estaciones, incluido un valor `All` que incluya todas las estaciones:</span><span class="sxs-lookup"><span data-stu-id="d74a6-169">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="d74a6-170">En el ejemplo siguiente se muestran las declaraciones de ambas enumeraciones anteriores:</span><span class="sxs-lookup"><span data-stu-id="d74a6-170">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="d74a6-171">Tipos que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="d74a6-171">Nullable types</span></span>

<span data-ttu-id="d74a6-172">Las variables de cualquier tipo se pueden declarar como _*_que no aceptan valores NULL_*_ o _*_que admiten un valor NULL_*_.</span><span class="sxs-lookup"><span data-stu-id="d74a6-172">Variables of any type may be declared as _*_non-nullable_*_ or _*_nullable_*_.</span></span> <span data-ttu-id="d74a6-173">Una variable que acepta valores NULL puede contener un valor `null` adicional que no indica valor alguno.</span><span class="sxs-lookup"><span data-stu-id="d74a6-173">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="d74a6-174">Los tipos de valor que aceptan valores NULL (estructuras o enumeraciones) se representan mediante <xref:System.Nullable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d74a6-174">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d74a6-175">Los tipos de referencia que no aceptan valores NULL y los que sí aceptan valores NULL se representan mediante el tipo de referencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="d74a6-175">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="d74a6-176">La distinción se representa mediante metadatos leídos por el compilador y algunas bibliotecas.</span><span class="sxs-lookup"><span data-stu-id="d74a6-176">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="d74a6-177">El compilador proporciona advertencias cuando se desreferencian las referencias que aceptan valores NULL sin comprobar primero su valor con `null`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-177">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="d74a6-178">El compilador también proporciona advertencias cuando las referencias que no aceptan valores NULL se asignan a un valor que puede ser `null`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-178">The compiler also provides warnings when non-nullable references are assigned a value that may be `null`.</span></span> <span data-ttu-id="d74a6-179">En el ejemplo siguiente se declara un elemento _*_int que admite un valor NULL_*_, y que se inicializa en `null`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-179">The following example declares a _*_nullable int_*_, initializing it to `null`.</span></span> <span data-ttu-id="d74a6-180">A continuación, establece el valor en `5`.</span><span class="sxs-lookup"><span data-stu-id="d74a6-180">Then, it sets the value to `5`.</span></span> <span data-ttu-id="d74a6-181">Muestra el mismo concepto con una _*_cadena que admite un valor NULL_*_.</span><span class="sxs-lookup"><span data-stu-id="d74a6-181">It demonstrates the same concept with a _*_nullable string_*_.</span></span> <span data-ttu-id="d74a6-182">Para más información, consulte [Tipos de valor que admiten un valor NULL](../language-reference/builtin-types/nullable-value-types.md) y [Tipos de referencia que aceptan valores NULL](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="d74a6-182">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="d74a6-183">Tuplas</span><span class="sxs-lookup"><span data-stu-id="d74a6-183">Tuples</span></span>

<span data-ttu-id="d74a6-184">C# admite [_ *_tuplas_*\*](../language-reference/builtin-types/value-tuples.md), lo que proporciona una sintaxis concisa para agrupar varios elementos de datos en una estructura de datos ligera.</span><span class="sxs-lookup"><span data-stu-id="d74a6-184">C# supports [_ *_tuples_*\*](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="d74a6-185">Puede crear una instancia de una tupla declarando los tipos y los nombres de los miembros entre `(` y `)`, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="d74a6-185">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="d74a6-186">Las tuplas proporcionan una alternativa para la estructura de datos con varios miembros sin usar los bloques de creación que se describen en el siguiente artículo.</span><span class="sxs-lookup"><span data-stu-id="d74a6-186">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d74a6-187">[Anterior](index.md)
>[Siguiente](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="d74a6-187">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
